静态代理：代理对象和被目标对象（被代理对象）需要实现同一个接口或者继承相同的父类。
         代理类是要手动编写的，在编译时期就产生代理对象了。
优点：
在没有改变原有代码的情况下就可以对目标对象做增强
缺点：
如果公共接口或父类做改动 需要大量维护代理类和目标类

动态代理就是解决静态代理的这个缺点的
动态代理：JDK动态代理、CGLIB动态代理  运行时动态生成代理对象  代理类不需要手动编写
         而是通过反射生成的
JDK动态代理：
        基于接口的动态代理
        1.通过实现 InvocationHandler 接口创建自己的调用处理器；
        2.通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；
        3.通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；
        4.通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。

CGLIB动态代理：
通过“继承”可以继承父类所有的公开方法，然后可以重写这些方法，在重写时对这些方法增强，这就是cglib的思想。
根据里氏代换原则（LSP），父类需要出现的地方，子类可以出现，所以cglib实现的代理也是可以被正常使用的。
cglib (Code Generation Library )是一个第三方代码生成类库，采用非常底层的字节码技术，
其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，
顺势织入横切逻辑
CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。



经测试，jdk创建对象的速度远大于cglib，这是由于cglib创建对象时需要操作字节码。
cglib执行速度略大于jdk，所以比较适合单例模式。
另外由于CGLIB的大部分类是直接对Java字节码进行操作，这样生成的类会在Java的永久堆中。
如果动态代理操作过多，容易造成永久堆满，触发OutOfMemory异常。
spring默认使用jdk动态代理，如果类没有接口，则使用cglib。
